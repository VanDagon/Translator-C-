#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ALLOCATION_ERROR 2
#define SYNTAX_ERROR_LIBRARY 3
#define SYNTAX_ERROR_INPUT 4
#define DUPLICATE_FOUND 5
#define NO_DICTIONARY_PATH 6
#define DICTIONARY_FILE_NOT_FOUND 7

#define LETTERS "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

#define DICTIONARY_INITIAL_SIZE 1024

#define WORD_SIZE_INITIAL 32

#define WHITESPACE_CHARACTERS " \n"

unsigned long ByteCounter = 0;

struct dictionaryTuple{
    char * word;
    char * translation;
};
typedef struct dictionaryTuple dictionaryTuple;

struct dictionary{
    int wordCount;
    int allocatedSize;
    dictionaryTuple * list;
    int dictionaryRead;
};
typedef struct dictionary dictionary;

dictionary * initDictionary()
{
    dictionary * theDictionary = (dictionary *) malloc(sizeof(dictionary));
    ByteCounter+= sizeof(dictionary);
    theDictionary->wordCount = 0;
    theDictionary->dictionaryRead = 0;
    
    theDictionary->list = (dictionaryTuple*) malloc(DICTIONARY_INITIAL_SIZE * sizeof(dictionaryTuple));
    ByteCounter+= sizeof(dictionaryTuple) * DICTIONARY_INITIAL_SIZE;
    theDictionary->allocatedSize = DICTIONARY_INITIAL_SIZE;

    return theDictionary;
}

int checkChar(char c, char * delims) // checks if char 'c' is a separator
{
    return (strchr(delims,c)!=NULL); // strchr returns NULL if 'c' is not found in 'delims'
    // returns 1 if c is in delims, 0 otherwie
}

void freeDictionary(dictionary * theDictionary)
{

    for (int i = 0; i <theDictionary->wordCount; i ++)
    {
        free(theDictionary->list[i].word);
        free(theDictionary->list[i].translation);
    }
    free(theDictionary->list);
    free(theDictionary);
}

char * safeRealloc(char * target, int targetSize, dictionary * theDictionary)
{
    char * testBuffer = (char *) realloc(target,(sizeof(char)*targetSize));
    ByteCounter+= sizeof(char) * targetSize;
    if (testBuffer == NULL)
    {
        perror("[safeRealloc]: failed to reallocate target. exiting...");
        freeDictionary(theDictionary);
        exit(ALLOCATION_ERROR);
    }
    else
    {
        return testBuffer;
    }
}

char * readNextWord(FILE * f, dictionary * theDictionary)
{
    char ch;
    char * read = (char *) malloc(sizeof(char) *WORD_SIZE_INITIAL);
    ByteCounter+= WORD_SIZE_INITIAL;
    
    int allocatedSize = WORD_SIZE_INITIAL;
    int charCounter = 0;
    int charCondition;

    while (1)
    {   
        ch = fgetc(f);
        

        charCondition = ((((ch==10) || (ch>126)) || ((ch<32) || (ch=='\n'))) || ((ch==':') && (charCounter==0)) );

        if (ch==EOF)
        {
            theDictionary->dictionaryRead = 1;
            free(read);
            return NULL;
        }

        if (charCondition)
        {
            free(read);
            freeDictionary(theDictionary);
            fprintf(stderr,"[readNextWord]: invalid format in dictionary. exiting...");
            exit(SYNTAX_ERROR_LIBRARY);
        }

        else if (ch == ':')
        {   
            read[charCounter] = '\0';
            read = safeRealloc(read,strlen(read)+1,theDictionary);
            return read;
        }
        else
        {
            if (charCounter>=allocatedSize)
            {
                read = safeRealloc(read,allocatedSize*2,theDictionary);
                allocatedSize*=2;
            }
            read[charCounter++] = ch;   
        }
        
    }

    return read;
}

char * readNextTranslation(FILE * f, dictionary * theDictionary)
{
    char ch;
    char * read = (char *) malloc(sizeof(char)* WORD_SIZE_INITIAL);
    ByteCounter+= WORD_SIZE_INITIAL;
    int allocatedSize = WORD_SIZE_INITIAL;
    int charCounter = 0;
    int charCondition; 

    while (1)
    {   
        ch = fgetc(f);
        charCondition = (( (ch>126) || (ch<32) ) || (ch == ':'));

        if (ch==EOF)
        {
            if (charCounter==0){
                free(read);
                fprintf(stderr,"[readNextTranslation]: invalid format in dictionary. exiting...");
                freeDictionary(theDictionary);
                exit(SYNTAX_ERROR_LIBRARY);
            }
            theDictionary->dictionaryRead = 1;
            read[charCounter] = '\0';
            return read;
        }
        else if (ch == '\n')
        {   
            if (charCounter==0){
                free(read);
                fprintf(stderr,"[readNextTranslation]: invalid format in dictionary. exiting...");
                freeDictionary(theDictionary);
                exit(SYNTAX_ERROR_LIBRARY);
            }
            read[charCounter] = '\0';
            read = safeRealloc(read,strlen(read)+1,theDictionary);
            return read;
        }
        else if (charCondition)
        {
            free(read);
            fprintf(stderr,"[readNextTranslation]: invalid format in dictionary. exiting...");
            freeDictionary(theDictionary);
            exit(SYNTAX_ERROR_LIBRARY);
        }
        else
        {
            if (charCounter>=allocatedSize)
            {
                read = safeRealloc(read,allocatedSize*2,theDictionary);
                allocatedSize*=2;
            }
            read[charCounter++] = ch;   
        }
        
    }

    return read;
}

dictionary * reallocDictionary(dictionary * theDictionary, int targetSize)
{
    if (targetSize==0)
    {
        targetSize = 1;
    }

    dictionaryTuple * testBuffer = (dictionaryTuple *) realloc(theDictionary->list,sizeof(dictionaryTuple) * targetSize);

    ByteCounter+= sizeof(dictionaryTuple) * targetSize;

    if (testBuffer == NULL)
    {
        perror("[reallocDictionary]: failed to reallocate theDictionary->list. exiting...");
        freeDictionary(theDictionary);
        exit(ALLOCATION_ERROR);
    }

    theDictionary->list = testBuffer;

    for (int i = 0; i < theDictionary->wordCount-1; i ++)
    {
        testBuffer[i] = theDictionary->list[i];
    }

    theDictionary->allocatedSize = targetSize;

    return theDictionary;
}

dictionary * loadDictionary(char * fileName)
{
    FILE * f = fopen(fileName,"r");
    if (f==NULL)
    {
        fprintf(stderr,"[loadDictionary]: file \"%s\" does not exist. exiting...\n",fileName);
        exit(DICTIONARY_FILE_NOT_FOUND);
    }

    //ByteCounter += BUFSIZ;
    dictionary * theDictionary = initDictionary();

    while (theDictionary->dictionaryRead==0)
    {
        
        if (theDictionary->wordCount>=theDictionary->allocatedSize)
        {
            theDictionary = reallocDictionary(theDictionary,theDictionary->allocatedSize*2);

        }

        theDictionary->list[theDictionary->wordCount].word = readNextWord(f,theDictionary);

        if (theDictionary->list[theDictionary->wordCount].word == NULL)
        {
            
            break;
        }

        theDictionary->list[theDictionary->wordCount].translation = readNextTranslation(f,theDictionary);
        theDictionary->wordCount++;
    } 

    theDictionary = reallocDictionary(theDictionary,theDictionary->wordCount);

    fclose(f);
    return theDictionary;
} 

void printDictionary(dictionary * theDictionary)
{
    for (int i = 0; i < theDictionary->wordCount-1; i ++)
    {
        printf("%s:%s\n",theDictionary->list[i].word,theDictionary->list[i].translation);
    }
    printf("%s:%s",theDictionary->list[theDictionary->wordCount-1].word,theDictionary->list[theDictionary->wordCount-1].translation);

}

int compare(const void *s1, const void *s2)
{
    struct dictionaryTuple *e1 = (struct dictionaryTuple *)s1;
    struct dictionaryTuple *e2 = (struct dictionaryTuple *)s2;

    return strcmp(e1->word,e2->word);
}

void qSortLibrary(struct dictionary * theDictionary)
{
    struct dictionaryTuple * base = &theDictionary->list[0];
    int l = theDictionary->wordCount;
    qsort(base, l, sizeof(struct dictionaryTuple), compare);
}

// this should be used on sorted dictionary so that duplicates are next to each other
void checkForDuplicate(dictionary * theDictionary) 
{
    for (int i = 0; i < theDictionary->wordCount-1; i ++)
    {
        if (!strcmp(theDictionary->list[i].word,theDictionary->list[i+1].word))
        {
            freeDictionary(theDictionary);
            fprintf(stderr,"[checkForDuplicate]: a duplicate word has been detected in  the dictionary. exiting...");
            exit(DUPLICATE_FOUND);
        }
    }
}

char * decapitalize(char * target) /// TO BE USED ONLY WITH target CONTAINING LETTERS OF ASCII
{
    // add error when target has a non-letter character
    size_t l = strlen(target);
    int l2 = l; // casting long unsigned to int?
    for (int i = 0 ; i < l2; i ++){
        target[i] += (target[i]<91) * 32;
    }

    return target;
}

char * findWord2(char * theWord, struct dictionary * theDictionary, int * wordNotFound)
{           
    int capital = (theWord[0] < 92); // find if first letter is capital
    theWord = decapitalize(theWord); // decapitalize
    int l = theDictionary->wordCount;
 
    struct dictionaryTuple key; 
    key.word = theWord; 

    struct dictionaryTuple * foundTuple = (struct dictionaryTuple *) bsearch(&key, theDictionary->list, l, sizeof(struct dictionaryTuple), compare);

    if( foundTuple != NULL ) {

        char * found = (char *) malloc (sizeof(char) * strlen(foundTuple->translation)+1);
        //strcpy(found,foundTuple->translation);
        found[0] = '\0';
        strcat(found,foundTuple->translation);  
        return found;
    }  

    char * notFound = (char *) malloc(sizeof(char) * (5+strlen(theWord))); 
    notFound[0] = '<';
    notFound[1] = '\0';
    strcat(notFound,theWord);
    strcat(notFound,">\0");  
    notFound[1] -= capital * 32; // recapitalize 
    if (*wordNotFound != 1) {*wordNotFound = 1;}
    return notFound;

}

int parseAndPrint2(char * delims, struct dictionary * theDictionary)
{
    //freopen( "a.txt", "w", stdout ); // stdout to file a.txt
    int charCounter = 0 ;
    char ch;
    char * word = (char * ) malloc(sizeof(char) * WORD_SIZE_INITIAL);
    char * t1;
    int allocatedSize = WORD_SIZE_INITIAL; 
    int wordNotFound = 0;

    while ((ch = getc(stdin)) != EOF){
 
        if (!checkChar(ch,delims))
        {
            if (charCounter==0)
            {
                printf("%c",ch);
            }
            else
            {
                word[charCounter] = '\0'; 
                t1 = findWord2(word,theDictionary,&wordNotFound);
                printf("%s",t1);
                free(t1);       
                printf("%c",ch);
            }
            
            charCounter = 0;
            word = safeRealloc(word,WORD_SIZE_INITIAL+1,theDictionary);
            allocatedSize = WORD_SIZE_INITIAL;
            //strcpy(word,"");
        }
        else
        {
            word[charCounter] = ch;
            charCounter++;

            if (charCounter>=allocatedSize) // realloc more bytes for word if needed
            {
                //allocatedSize = buffWord(word,allocatedSize);
                //word = (char *) realloc(word,sizeof(char) * (allocatedSize*2));
                word = safeRealloc(word,allocatedSize*2,theDictionary);
                allocatedSize *= 2;
            } 

        }
    
    }

    if ((ch == EOF) && (charCounter>0)) // when the input ends with a letter before EOF
    {
        word[charCounter] = '\0';
        t1 = findWord2(word,theDictionary,&wordNotFound);
        printf("%s",t1);
        free(t1);
    }

    free(word);
    return wordNotFound;
}


int main(int argc, char ** argv) {
    if (argc==1)
    {
        fprintf(stderr,"dictionary path missing. exiting...");
        exit(NO_DICTIONARY_PATH);
    }
    int wordNotFound = 0;
    dictionary * D1 = loadDictionary(argv[1]);
    //printf("%lu\n",ByteCounter+1024);

    qSortLibrary(D1);
    checkForDuplicate(D1);
    //printDictionary(D1);
    if (D1->wordCount==0){exit(EXIT_SUCCESS);}
    wordNotFound = parseAndPrint2(LETTERS,D1);
    freeDictionary(D1); 

    return wordNotFound;
}

