#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define LETTERS "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
#define LIBRARY_NAME "example03.wb"
#define BUFFER_SIZE 1024
#define LINE_SIZE_INITIAL 1024
#define WORD_SIZE_INITIAL 64
#define DICTIONARY_INITIAL_SIZE 1024 // these many words (struct dictionaryTuple object for each)
#define INPUT_INITIAL_SIZE 1024*1024 // ~1024 lines with 1024 characters (1 million bytes / 1MB)
#define INPUT_BUFFER_SIZE 1024*1024 // add 1024 lines per buff

struct dictionaryTuple{
    char * word;
    char * translation;
};

struct dictionary{
    struct dictionaryTuple * words;
    int wordCount;
    int allocatedSize;
};

//generates, initializes and returns a struct dictionary object
struct dictionary * initDictionary() 
{
    struct dictionary * result = malloc(sizeof(struct dictionary));
    result->wordCount = 0;
    result->words = (struct dictionaryTuple*) malloc(sizeof(struct dictionaryTuple) * DICTIONARY_INITIAL_SIZE );
    result->allocatedSize = DICTIONARY_INITIAL_SIZE;
    return result;
}

struct dictionaryTuple * parseLine(char * line){

    char * token;
    char delims[] = ":\nEOF";
    struct dictionaryTuple * thisTuple = (struct dictionaryTuple*) malloc (sizeof(struct dictionaryTuple));

    token = strtok(line,delims);
    thisTuple->word = token; //replaceWord(token)
    token = strtok(NULL,delims);
    thisTuple->translation = token; //replaceWord(token);

    return thisTuple;
}

void buffDictionary(struct dictionary * theDictionary) 
{

    struct dictionaryTuple * testBuffer = (struct dictionaryTuple*)
        realloc(theDictionary->words,sizeof(struct dictionaryTuple) * (theDictionary->allocatedSize + BUFFER_SIZE));

    if (testBuffer==NULL)
    {
        perror("buffDictionary: failed to allocate extra memory for dictionary");
    }
    else
    {
        theDictionary->words = testBuffer;
        theDictionary->allocatedSize+= WORD_SIZE_INITIAL;
        //printf("Dictionary successfully buffed to %d words\n",theDictionary->allocatedSize);
    }
}

struct dictionary * loadDictionary(char * fileName)
{
    size_t read;
    size_t len;
    char * line = (char *) malloc(sizeof(char) * LINE_SIZE_INITIAL);
    FILE * f;

    struct dictionary * theDictionary = initDictionary();

    f = fopen(fileName,"r");
    // if (read > sizeof(line)) {buffLine(line);}//////////////
    while ((read = getline(&line, &len, f)) != -1)
    {
        if (theDictionary->wordCount>=theDictionary->allocatedSize)
        {
            buffDictionary(theDictionary);
        } 
        struct dictionaryTuple * thisTuple = (struct dictionaryTuple*) malloc(sizeof(struct dictionaryTuple));
        thisTuple = parseLine(line);
        theDictionary->words[theDictionary->wordCount].word = (char *) malloc(sizeof(char) * WORD_SIZE_INITIAL);////////////
        theDictionary->words[theDictionary->wordCount].translation = (char *) malloc(sizeof(char) * WORD_SIZE_INITIAL);/////////////
        strcpy(theDictionary->words[theDictionary->wordCount].word,thisTuple->word);
        strcpy(theDictionary->words[theDictionary->wordCount].translation,thisTuple->translation);
        theDictionary->wordCount++;
        free(thisTuple);
    } 

    fclose(f);
    return theDictionary;
}

void printDictionary(struct dictionary * theDictionary)
{
    int l = theDictionary->wordCount;
    printf("~~PRINTING DICTIONARY:\n");
    for (int i = 0 ; i < l; i ++)
    {
        printf("WORDS[%d] - %s:%s\n",i,theDictionary->words[i].word,theDictionary->words[i].translation);
    }
    printf("~~END OF DICTIONARY~~\n");
    return;
}

int buffInputString(char * inputString, int currentSize)
{
    int newSize = currentSize;
    char * testBuffer = (char *) realloc(inputString, currentSize + INPUT_BUFFER_SIZE);

    if (testBuffer==NULL)
    {
        perror("buffInputString: failed to allocate extra memory for input");
    }
    else
    {
        inputString = testBuffer;
        newSize+= INPUT_BUFFER_SIZE;
    }

    return newSize;    
} 

int buffWord(char * word, int currentSize)
{
    int newSize = currentSize;
    char * testBuffer = (char *) realloc(word, currentSize + BUFFER_SIZE);

    if (testBuffer==NULL)
    {
        perror("buffInputString: failed to allocate extra memory for input");
    }
    else
    {
        word = testBuffer;
        newSize+= BUFFER_SIZE;
    }

    return newSize; 
}

char * readStdInput()
{
    char * result = (char* ) malloc(sizeof(char) * INPUT_INITIAL_SIZE);
    int charCounter = 0, allocatedSize = INPUT_INITIAL_SIZE; //// >????? 
    char ch;
    while ((ch = getc(stdin)) != EOF)
    {
        if (charCounter > allocatedSize)
        {
            printf("BUFFING INPUT\n");
            allocatedSize = buffInputString(result,allocatedSize);
        }

        result[charCounter] = ch;
        charCounter++; 

    }
    //result[charCounter] = "\0"; ???

    return result;
}

int checkChar(char c, char * delims) // checks if char 'c' is a separator
{
    return (strchr(delims,c)!=NULL); // strchr returns NULL if 'c' is not found in 'delims'
    // returns 1 if c is letter, 0 otherwise
}

char * assembleNextWord(int * i, char * input, char * delims){

    char ch = input[*i];
    int charCounter = 0;
    char * word = (char * ) malloc(sizeof(char) * WORD_SIZE_INITIAL);

    while (checkChar(ch,delims))
    {
        word[charCounter++] = ch;
        (*i)++;
        ch = input[*i]; 
    }

    word[charCounter] = '\0';

    return word;
}

// check if target contains capital letters
// return 0 if no capital letters
// return 1 if only the first character is capital
// return 2 if all characters are capital
int caps(char * target)
{
    size_t l = strlen(target);
    int allCaps = (target[0] < 91) * 2;
    int firstCap = (target[0] < 91);
    for (int i = 1 ; i < l; i ++)
    {
        if (target[i] > 91)
        {
            allCaps = 0;
        }
        else
        {
            firstCap = 0;
        }
        
    }
    
    return firstCap + allCaps;
}

char * decapitalize(char * target) /// TO BE USED ONLY WITH target CONTAINING LETTERS
{
    size_t l = strlen(target);
    for (int i = 0 ; i < l; i ++){
        target[i] += (target[i]<91) * 32;
    }

    return target;
}

char * capitalize(char * target, int cp) /// TO BE USED ONLY WITH target CONTAINING LETTERS
{
    size_t l = strlen(target);
    if (cp == 2){
        for (int i = 0 ; i < l; i ++){
            target[i] -=  32;
        }
    }
    else if (cp == 1)
    {
        target[0] -= 32;
    }
    
    return target;
}

char * findWord(char * theWord, struct dictionary * theDictionary)
{            
    int capital = caps(theWord); // find if first letter is capital
    if (capital>0){theWord = decapitalize(theWord);} // decapitalize
    int l = theDictionary->wordCount;
    for (int i = 0 ; i < l ; i++)
    {
        
        if (!strcmp(theDictionary->words[i].word,theWord))
        {
            char * found = (char *) malloc(sizeof(char) * strlen(theDictionary->words[i].translation));
            strcpy(found,theDictionary->words[i].translation);
            if (capital>0){theWord = capitalize(found,capital);} // recapitalize
            return found;
        }
    }

    char * notFound = (char *) malloc(sizeof(char) * (5+strlen(theWord))); 
    notFound[0] = '<';
    notFound[1] = ' ';
    notFound[2] = '\0';
    if (capital>0){theWord = capitalize(theWord,capital);} // recapitalize
    strcat(notFound,theWord);
    strcat(notFound," >\0");

    return notFound;
}

void parseAndPrint(char * inputString, char * delims, struct dictionary * theDictionary)
{
    size_t len = strlen(inputString);
    int * index = (int *) malloc(sizeof(int));
    *index = 0;
    char ch;

    while ((*index)<len)
    {   
        ch = inputString[*index];
        if (!checkChar(ch,delims))
        {
            printf("%c",ch);
            (*index)++;
        }
        else // *index is incremented by assembleNextWord
        {
            printf("%s",findWord(assembleNextWord(index,inputString,delims),theDictionary));
        }   
        
    }

    return;
}

int main() {
    struct dictionary * D1 = (struct dictionary*) malloc(sizeof(struct dictionary));
    D1 = loadDictionary(LIBRARY_NAME);
    char * inp = readStdInput();
    parseAndPrint(inp,LETTERS,D1); 
    return 0;
}

