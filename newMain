#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define LETTERS "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
#define LIBRARY_NAME "demo.wb"
#define BUFFER_SIZE 1024
#define LINE_SIZE_INITIAL 1024
#define WORD_SIZE_INITIAL 64
#define DICTIONARY_INITIAL_SIZE 8 // these many words (struct dictionaryTuple object for each)
#define INPUT_INITIAL_SIZE 1024*1024 // ~1024 lines with 1024 characters (1 million bytes / 1MB)
#define INPUT_BUFFER_SIZE 1024*1024 // add 1024 lines per buff

struct dictionaryTuple{
    char * word;
    char * translation;
};

struct dictionary{
    struct dictionaryTuple * words;
    int wordCount;
    int allocatedSize;
};

//generates, initializes and returns a struct dictionary object
struct dictionary * initDictionary() 
{
    struct dictionary * result = malloc(sizeof(struct dictionary));
    result->wordCount = 0;
    result->words = (struct dictionaryTuple*) malloc(sizeof(struct dictionaryTuple) * DICTIONARY_INITIAL_SIZE );
    result->allocatedSize = DICTIONARY_INITIAL_SIZE;
    return result;
}

struct dictionaryTuple * parseLine(char * line){

    char * token;
    char delims[] = ":\nEOF";
    struct dictionaryTuple * thisTuple = (struct dictionaryTuple*) malloc (sizeof(struct dictionaryTuple));

    token = strtok(line,delims);
    thisTuple->word = token; //replaceWord(token)
    token = strtok(NULL,delims);
    thisTuple->translation = token; //replaceWord(token);

    return thisTuple;
}

void buffDictionary(struct dictionary * theDictionary) 
{

    struct dictionaryTuple * testBuffer = (struct dictionaryTuple*)
        realloc(theDictionary->words,sizeof(struct dictionaryTuple) * (theDictionary->allocatedSize + BUFFER_SIZE));

    if (testBuffer==NULL)
    {
        perror("buffDictionary: failed to allocate extra memory for dictionary");
    }
    else
    {
        theDictionary->words = testBuffer;
        theDictionary->allocatedSize+= WORD_SIZE_INITIAL;
        //printf("Dictionary successfully buffed to %d words\n",theDictionary->allocatedSize);
    }
}

struct dictionary * loadDictionary(char * fileName)
{
    size_t read;
    size_t len;
    char * line = (char *) malloc(sizeof(char) * LINE_SIZE_INITIAL);
    FILE * f;

    struct dictionary * theDictionary = initDictionary();

    f = fopen(fileName,"r");
    // if (read > sizeof(line)) {buffLine(line);}//////////////
    while ((read = getline(&line, &len, f)) != -1)
    {
        if (theDictionary->wordCount>=theDictionary->allocatedSize)
        {
            buffDictionary(theDictionary);
        } 
        struct dictionaryTuple * thisTuple = (struct dictionaryTuple*) malloc(sizeof(struct dictionaryTuple));
        thisTuple = parseLine(line);
        //printf("%s:%s\n",thisTuple->word,thisTuple->translation);
        theDictionary->words[theDictionary->wordCount].word = (char *) malloc(sizeof(char) * WORD_SIZE_INITIAL);
        theDictionary->words[theDictionary->wordCount].translation = (char *) malloc(sizeof(char) * WORD_SIZE_INITIAL);
        strcpy(theDictionary->words[theDictionary->wordCount].word,thisTuple->word);
        strcpy(theDictionary->words[theDictionary->wordCount].translation,thisTuple->translation);
        theDictionary->wordCount++;
        free(thisTuple);
    } 

    fclose(f);
    return theDictionary;
}

void printDictionary(struct dictionary * theDictionary)
{
    int l = theDictionary->wordCount;
    printf("~~PRINTING DICTIONARY:\n");
    for (int i = 0 ; i < l; i ++)
    {
        printf("WORDS[%d] - %s:%s\n",i,theDictionary->words[i].word,theDictionary->words[i].translation);
    }
    printf("~~END OF DICTIONARY~~\n");
    return;
}

int buffInputString(char * inputString, int currentSize)
{
    int newSize = currentSize;
    char * testBuffer = (char *) realloc(inputString, currentSize + INPUT_BUFFER_SIZE);

    if (testBuffer==NULL)
    {
        perror("buffInputString: failed to allocate extra memory for input");
    }
    else
    {
        inputString = testBuffer;
        newSize+= INPUT_BUFFER_SIZE;
    }

    return newSize;    
} 

int buffWord(char * word, int currentSize)
{
    int newSize = currentSize;
    char * testBuffer = (char *) realloc(word, currentSize + BUFFER_SIZE);

    if (testBuffer==NULL)
    {
        perror("buffInputString: failed to allocate extra memory for input");
    }
    else
    {
        word = testBuffer;
        newSize+= BUFFER_SIZE;
    }

    return newSize; 
}

char * readStdInput()
{
    char * result = (char* ) malloc(sizeof(char) * INPUT_INITIAL_SIZE);
    int charCounter = 0, allocatedSize = INPUT_INITIAL_SIZE; //// >????? 
    char ch;
    while ((ch = getc(stdin)) != EOF)
    {
        if (charCounter > allocatedSize)
        {
            printf("BUFFING INPUT\n");
            allocatedSize = buffInputString(result,allocatedSize);
        }

        result[charCounter] = ch;
        charCounter++; 

    }
    //result[charCounter] = "\0"; ???

    return result;
}

int checkChar(char c, char * delims) // checks if char 'c' is a separator
{
    return (strchr(delims,c)==NULL); // strchr returns NULL if 'c' is not found in 'delims'
    // returns 1 if c is letter, 0 otherwise
}

char * assembleNextWord(char * input, int * currentIndex, char * delims) ////////////////////
{
    char * result = (char *) malloc(WORD_SIZE_INITIAL);
    int allocatedSize = WORD_SIZE_INITIAL;    
    int charCounter = 0;  
    char ch = input[*currentIndex];

    if (!checkChar(ch,delims))
    {
        printf("%c",ch);
    }

    while(checkChar(ch,delims))
    {
        if (charCounter>allocatedSize)
        {
            allocatedSize = buffWord(result,allocatedSize);
        }
        result[charCounter] = ch;
        charCounter++;
        *currentIndex++;
        ch = input[*currentIndex];
    }

    printf("%c",ch);
    return result;
}

char * findWord(char * theWord, struct dictionary * theDictionary)
{            
    int l = theDictionary->wordCount;
    for (int i = 0 ; i < l ; i++)
    {
        
        if (!strcmp(theDictionary->words[i].word,theWord))
        {
            return theDictionary->words[i].translation;
        }
    }

    char * notFound = (char *) malloc(sizeof(char) * (5+strlen(theWord))); 
    strcat(notFound,"< ");
    strcat(notFound,theWord);
    strcat(notFound," >\0");

    return notFound;
}

void parseAndPrint(char * inputString, char * delims, struct dictionary * theDictionary)
{
    size_t len = strlen(inputString);
    int * index;
    *index = 0;

    while (*index<len)
    {   
        printf("%s",findWord(assembleNextWord(inputString,index,delims),theDictionary));
    }

}

int main() {
    struct dictionary * D1 = (struct dictionary*) malloc(sizeof(struct dictionary));
    D1 = loadDictionary(LIBRARY_NAME);
    char * inp = readStdInput();
    char * q = "das";
    //printf("%s\n",findWord(q,D1));
    //parseAndPrint(inp,LETTERS,D1);
    return 0;
}

