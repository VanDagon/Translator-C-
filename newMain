#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define LIBRARY_NAME "demo.wb"
#define BUFFER_SIZE 1024
#define LINE_SIZE_INITIAL 1024
#define WORD_SIZE_INITIAL 64
#define DICTIONARY_INITIAL_SIZE 1024 // these many words (struct dictionaryTuple object for each)
#define INPUT_INITIAL_SIZE 1024*1024 // ~1024 lines with 1024 characters (1 million bytes / 1MB)
#define INPUT_BUFFER_SIZE 1024*1024 // add 1024 lines per buff

struct dictionaryTuple{
    char * word;
    char * translation;
};

struct dictionary{
    struct dictionaryTuple * words;
    int wordCount;
};

struct dictionary * initDictionary()
{
    struct dictionary * result = malloc(sizeof(struct dictionary));
    result->wordCount = 0;
    result->words = (struct dictionaryTuple*) malloc(sizeof(struct dictionaryTuple) * DICTIONARY_INITIAL_SIZE );
    return result;
}

struct dictionaryTuple * parseLine(char * line){

    char * token;
    char delims[] = ":\nEOF";
    struct dictionaryTuple * thisTuple = (struct dictionaryTuple*) malloc (sizeof(struct dictionaryTuple));

    token = strtok(line,delims);
    thisTuple->word = token; //replaceWord(token)
    token = strtok(NULL,delims);
    thisTuple->translation = token; //replaceWord(token);

    return thisTuple;
}

int buffDictionary(struct dictionaryTuple * thisTuple, int currentSize) 
{
    int newSize = currentSize;
    struct dictionaryTuple * testBuffer = (struct dictionaryTuple*)
        realloc(thisTuple,sizeof(struct dictionaryTuple) * (currentSize + BUFFER_SIZE));

    if (testBuffer==NULL)
    {
        perror("buffDictionary: failed to allocate extra memory for dictionary");
    }
    else
    {
        thisTuple = testBuffer;
        newSize+= WORD_SIZE_INITIAL;
    }

    return newSize;
}

struct dictionaryTuple * loadDictionary(char * fileName)
{
    size_t read;
    size_t len;
    char * line;
    int wordCount = 0;
    FILE * f;
    struct dictionaryTuple * result = (struct dictionaryTuple*) 
        malloc(sizeof(struct dictionaryTuple) * DICTIONARY_INITIAL_SIZE);
        int allocatedSize = DICTIONARY_INITIAL_SIZE;  

    f = fopen(fileName,"r");

    while ((read = getline(&line, &len, f)) != -1) {
        if (wordCount >= allocatedSize)
        {
            printf("HEREREREREEHETE!");
            allocatedSize = buffDictionary(result, allocatedSize);
        }

        result[wordCount] = *parseLine(line);
        wordCount++;
    }

    return result;
}

int buffInputString(char * inputString, int currentSize)
{
    int newSize = currentSize;
    char * testBuffer = (char *) realloc(inputString, currentSize + INPUT_BUFFER_SIZE);

    if (testBuffer==NULL)
    {
        perror("buffInputString: failed to allocate extra memory for input");
    }
    else
    {
        inputString = testBuffer;
        newSize+= INPUT_BUFFER_SIZE;
    }

    return newSize;    
} 

int buffWord(char * word, int currentSize)
{
    int newSize = currentSize;
    char * testBuffer = (char *) realloc(word, currentSize + BUFFER_SIZE);

    if (testBuffer==NULL)
    {
        perror("buffInputString: failed to allocate extra memory for input");
    }
    else
    {
        word = testBuffer;
        newSize+= BUFFER_SIZE;
    }

    return newSize; 
}

char * readStdInput()
{
    char * result = (char* ) malloc(INPUT_INITIAL_SIZE);
    int charCounter = 0, allocatedSize = INPUT_INITIAL_SIZE;//// >????? 
    char ch;
    while (ch = getc(stdin) != EOF)
    {
        if (charCounter > allocatedSize)
        {
            allocatedSize = buffInputString(result,allocatedSize);
        }

        result[charCounter] = ch;
        charCounter++; 

    }

    return result;
}

int checkChar(char c, char * delims) // checks if char 'c' is a separator
{
    return (strchr(delims,c)==NULL); // strchr returns NULL if 'c' is not found in 'delims'
    // returns 1 if c is letter, 0 otherwise
}

char * assembleNextWord(char * input, int * currentIndex, char * delims)
{
    char * result = (char *) malloc(WORD_SIZE_INITIAL);
    int allocatedSize = WORD_SIZE_INITIAL;    
    int charCounter = 0;  
    char ch = input[*currentIndex];

    if (!checkChar(ch,delims))
    {
        printf("%c",ch);
    }

    while(checkChar(ch,delims))
    {
        if (charCounter>allocatedSize)
        {
            allocatedSize = buffWord(result,allocatedSize);
        }
        result[charCounter] = ch;
        charCounter++;
        *currentIndex++;
        ch = input[*currentIndex];
    }

    printf("%c",ch);
    return result;
}

char * findWord(char * word)
{
    char * result;


    return result;
}

void parseAndPrint(char * inputString, char * delims)
{
    size_t len = strlen(inputString);
    int * index;
    *index = 0;

    while (*index<len)
    {
        
        printf("%s",findWord(assembleNextWord(inputString,index,delims)));
    }

}

int main() {
    char * delims1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; // non-separators
    //struct dictionaryTuple * dict = loadDictionary(LIBRARY_NAME);
    //printf("%s",dict[0].word);
    //char * inp = readStdInput();
    //parseAndPrint(inp,delims1);

    return 0;
}

